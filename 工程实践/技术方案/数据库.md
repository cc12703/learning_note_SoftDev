


# 数据库

[TOC]


## 事务隔离级别
### 要点
* 是否脏读：其他事务是否会读到本事务未提交时的数据
* 是否可重复读：本事务在执行中，是否读到其他已提交事务对数据的更新

### 常用级别
* RC：能读到已提交的数据，无脏读
* RR：可重复读，无脏读


## 主从同步机制
### 主体流程
主库
1. 提交事务
1. 更新存储引擎中的数据
1. 将Binlog写入磁盘
1. 向客户端返回响应
1. 把Binlog复制给从库

从库
1. 把Binlog写入暂存日志
1. 回放Binlog
1. 更新存储引擎中的数据
1. 向主库返回成功响应

### 异步复制
* 执行事务操作的线程不会等待复制Binlog的线程
    * 主库在事务提交完成后，直接向客户端返回成功响应
    * 从库有一个专门的复制线程，接收Binlog写入中继日志

![](http://picbed.cc12703.com/20221216232614.png)

#### 问题
* 主库宕机会有丢失数据的风险



### 同步复制
* 主库在提交事务时，会等待数据复制到所有从库后，再向客户端返回响应

#### 问题
* 性能很差
* 可用性很差：任何一个数据库出错都会影响业务


### 半同步复制
* 事务线程只要收到一部分复制的响应，就可以向客户端返回响应




## 数据备份

### 方案
* 定期的全量备份 + Binlog增量备份

### 要点
* 备份数据需要放在不同城市、不同机房、不同服务器上
* 回放Binlog时，指定的起始时间可以比全量备份的时间稍微提前一点


## 高可用

### 概述
* 使用Binlog在主、备数据库之间实时同步
* 异步复制：主从延迟，从库的数据比主库上旧一些
* 同步复制：牺牲一些性能、需要两个从服务器

### 方案
* 一主一从、异步复制、自动切换
    * 可能会丢数据、性能好
* 一主二从、同步复制、自动切换
    * 不会丢数据、性能差


## 高并发

### 缓存
#### 概述
* 经典方案：MySQL + Redis（前置缓存）
* 适用条件：任何人的查询请求和响应数据都是一样的。

#### 更新策略
* R/W Through：更新数据库后，更新缓存。并行时会概率出现“脏数据”
* Cache Aside：更新数据库后，直接删除缓存

#### 缓存穿透
* 避免短时间内大量的请求无法命中缓存，请求穿透到数据库
* 方法：灰度发布、缓存预热


### 读写分离
#### 概述
* 使用多个有相同数据的实例来分担查询请求
* 适用条件：数据的读写请求严重不均衡（绝大多数都是查询请求）
* 使用`HAProxy + KeepAlived`做读节点的负载均衡

#### 图示
![](http://picbed.cc12703.com/20221215235636.png)


#### 分离读写请求
* 纯手工方式：修改DAO层代码
* 组件方式：使用Sharding-JDBC类似库（推荐）
* 代理方式：在应用和数据库之间部署一组数据库代理



## 海量数据

### 归档历史数据
* 前提：对于有时间属性的数据，大多数情况下都访问最近的数据（热尾效应）
* 方法：将大量的历史数据迁移到另一张历史表中
* 优点：改动的代码非常少


![](http://picbed.cc12703.com/20221217151225.png)


### 删除大量数据

#### 停机删除
1. 创建一个临时表
1. 将当前数据复制到临时表
1. 将旧表改名
1. 将临时表改名为正式表名

#### 在线删除
分批分量删除
1. 每次删除一定数量的记录（1000条）
1. 每次删除之间停顿一会


### 分库分表

#### 概述
* 原则：能不拆就不拆，能少拆就不多拆（开发和维护就越麻烦）
* 分表：解决数据量大而导致的查询慢
* 分库：解决并发请求量高
* 缺点：极大地限制数据库的查询能力


#### 分片算法

##### 范围分片
* 前提：数据量非常大，并发量不大的ToB系统
* 例子：使用时间字段
* 优点：对查询非常友好（只要加上一个范围值）
* 缺点：容易产生热点问题

##### 哈希分片
* 例子：订单表，使用用户ID
* 优点：容易将数据和查询均匀分布到分片中

##### 查表法
* 分片由人为分配，分配结果记录在一张表中
* 优点：更灵活