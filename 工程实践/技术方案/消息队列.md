



# 消息队列

[TOC]


## 总体


### 作用
* 异步处理：实现不同服务间的异步处理
* 流量控制：隔离网关和后端服务
* 服务解耦：将不同服务进行解耦




## 选型


### RabbitMQ

#### 优点
* 支持非常灵活的路由配置
* 支持非常多的不同语言的客户端

#### 缺点
* 对消息堆积支持不好，会导致性能急剧下降
* 性能不高：每秒处理几万-十几万条消息
* Erlang开发，二次开发比较难


### RocketMQ

#### 优点
* Java开发，二次开发比较容易
* 优化了在线业务的响应时延
* 性能比较好：每秒处理几十万条消息

#### 缺点
* 周边生态系统比较一般


### Kafka

#### 优点
* 设计上使用了批量和异步的思想
* 性能比较好：每秒处理几十万条消息
* 周边生态系统最好

#### 缺点
* 同步操作的响应时延比较高，不太适合在线业务




## 模型

### 基础

#### 队列模型
* 一份消息只能被消费一次

![](http://picbed.cc12703.com/20221123224800.png)


#### 发布-订阅模型
* 一份消sheng'c

![](http://picbed.cc12703.com/20221123225136.png)



### RabbitMQ
* 队列模型
* 一个Exchage模块来路由消息

![](http://picbed.cc12703.com/20221123234255.png)


### RocketMQ
* 发布-订阅模型
* 主题下包含多个队列，用于实现并行生产和消费

![](http://picbed.cc12703.com/20221123234840.png)






## 消息不丢失

### 丢失检测方法

#### 原理
* 消息队列的有序性
* 在生产端，给每个消息附加一个连续递增的序列号
* 在消费端，检查消息中序列号的连续性
* 如果检测到序号不连续了，就丢失消息了。

#### 要点
* 部分消息队列需要在每个分区中单独检测连续性（Kafka, RocketMQ）
* 如果生产端是多实例的，则需要每个实例单独生成序列号
* 消费端的实例数量最好和分区数量一致


### 传递过程

![](http://picbed.cc12703.com/20221124234859.png)

#### 生产阶段
* 使用请求确认机制，来保证可靠传递
* 写发送消息代码时，需要正确处理返回值、捕获异常

#### 存储阶段
* 单节点：收到消息后，将消息写入磁盘，给生产者发送确认响应
* 多节点：至少将消息发送到2个以上的节点后，给生产者发送确认响应

#### 消费阶段
* 使用请求确认机制，来保证可靠传递
* 写消费代码时，需要在执行完业务逻辑后，再发送确认响应



## 消息重复



## 消息积压

* 一定要保证消费端的性能高于生产端的性能，才能保证系统持续运行

### 消费端优化
* 优化业务逻辑
* 水平扩容：扩容消费端实例数量时，需要同步扩容主题中分区的数量。保证两者是一致的。