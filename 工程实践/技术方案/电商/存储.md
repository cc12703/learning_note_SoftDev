


# 存储

[TOC]


## 订单系统

### 核心表
* 订单主表：保存订单的基本信息
* 订单商品表：保存订单中的商品信息
* 订单支付表：保存订单中的支付、退款信息
* 订单优惠表：保存订单中使用的所有优惠信息


### 避免重复下单

#### 思路
利用数据库的唯一约束来使订单服务具备幂等性

#### 方法
1. 增加一个“生成订单号”的服务，每个订单带一个全局唯一的订单号

#### 时序图
![](http://picbed.cc12703.com/20221108194452.png)


### 避免ABA问题
新的订单信息被老的订单覆盖了

#### 问题时序图
![](http://picbed.cc12703.com/20221108194828.png)

#### 方法
1. 给订单表增加一列：版本号
1. 更新请求时需要带该版本号
1. 服务端需要检查请求中的版本好是否与当前版本号一致
    1. 若一致，则更新数据，版本号加一
    1. 若不一致，则不更新



                                     


## 商品系统


### 商品信息存储

#### 基本信息
1. 包括：标题、价格、颜色
1. 特点：数据不太大，变动频率低
1. 适合使用数据库保存（MySQL）

#### 商品参数
1. 含义：商品的特征信息，电脑的内存大小、手机的屏幕尺寸
1. 特点：不同类型的商品，参数完全不一样
1. 适合使用面向文档存储的NoSQL数据库（MongoDB）

#### 图片和视频
1. 特点：占用的存储空间比较大
1. 适合使用对象存储系统（七牛云、AWS的S3）


### 详情页静态化

#### 方法
1. 将详情页不会频繁变动的内容保存成一个静态html文件
1. 外部访问详情页时，直接返回该html文件
1. 其中需要频繁变动的内容使用AJAX动态获取


### 总结
![](http://picbed.cc12703.com/20221110193319.png)



## 购物车系统

### 暂存购物车

#### 总体
1. 商品保存在客户端
1. 可以使用Cookie或LocalStorage进行保存

#### Cookie
1. 容量有4K的限制
1. CS交互时都会自动带Cookie数据
1. 实现简单：全部逻辑可以在服务端实现


#### LocalStorage
1. 容量比较大
1. 实现复杂：客户端和服务器都需要实现部分逻辑


### 常规购物车

#### 总体
1. 商品保存在服务端
1. 可以使用MySQL或Redis进行保存

#### 结构
```json
{
    id <long> 自增主键
    user_id <long>  用户ID
    sku_id  <long>  商品ID
    count  <int>    商品数量
    timestamp <date> 加入时间
    selected  <int>  勾选状态
}
```

#### MySQL
1. 数据可靠性高
1. 支持丰富的查询方式和事务机制

#### Redis
1. 读写性能高
1. 有概率会丢失数据
1. 查询麻烦且低效



## 账户系统

### 余额管理
* 在记录余额时，同时记录流水（交易记录）
* 使用数据库事务来保证余额和流水的一致性
* 在两者不一致且无法通过业务手段修正时，使用流水来修正余额


### 账户流水
* 流水记录号只能新增，记录成功后就不能再修改和删除了。
* 取消交易需要记录一笔“取消交易”的流水
* 流水号必须是递增的。

### 交易实现步骤
余额表增加`log_id`属性（记录最后一笔交易的流水号）
1. 开启事务
1. 查询当前余额和最后一笔流水号
1. 写入新的流水记录
1. 更新余额（更新语句需要限定流水号等于步骤2查询到的流水号）
1. 检查更新返回值，成功就提交事务，否则就回滚事务







## 其他



### SQL优化

* 目标：避免写出“慢SQL”

#### 服务器处理能力
* 普通的服务器，能力极限大致是**每秒一万条简单SQL**
* 一般情况下，每秒执行几百条SQL，就已经非常繁忙了

#### 遍历记录数量
* 遍历记录数在**百万以内**，该查询是安全的
* 遍历记录数在**几百万级别**，需要考虑优化
* 遍历记录数达到**千万级别**，不应该出现（在线交易系统）




